package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"strings"
)

// isContiguous returns true if all of t's data (at least, the data that we
// care about) lies in one contiguous segment of memory. This includes all
// basic types (except strings), arrays of contiguous types, and structs
// containing only contiguous types.
func isContiguous(t types.Type) bool {
	switch t := t.Underlying().(type) {
	case *types.Basic:
		return t.Kind() != types.String
	case *types.Array:
		return isContiguous(t.Elem())
	case *types.Struct:
		for i := 0; i < t.NumFields(); i++ {
			if !isContiguous(t.Field(i).Type()) {
				return false
			}
		}
		return true
	}
	return false
}

func ref(name string, indir int) string {
	if indir > 0 {
		return deref(name, indir-1)
	}
	return "&" + name
}

func deref(name string, indir int) string {
	if indir > 0 {
		return strings.Repeat("*", indir) + name
	}
	return name
}

type generator struct {
	buf bytes.Buffer
}

func (g *generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalln("invalid Go generated:", err)
	}
	return src
}

func (g *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *generator) generateHeader(pkgName string) {
	g.Printf(`// Code generated by few; edit if you feel like it.

package %s

import (
	"errors"
	"io"
	"reflect"
	"unsafe"
)

var (
	_            unsafe.Pointer
	errNilObject = errors.New("cannot encode nil object")
	ptrTrue      = true
	ptrFalse     = false
)
`, pkgName)
}

func (g *generator) generateMethod(name string, t types.Type) {
	g.Printf(`
func (x *%s) WriteTo(w io.Writer) (total int64, err error) {
	if x == nil {
		return 0, errNilObject
	}
	var n int
	var sli *reflect.SliceHeader
	var str *reflect.StringHeader
	_, _, _ = n, sli, str // evade unused variable check
`, name)
	// indir=1 because x is a pointer
	g.generate("x", t, 1, 'i')
	g.Printf(`
	return
}
`)
}

// indir is the number of dereferences required to access name's data.
func (g *generator) generate(name string, t types.Type, indir int, loopVar byte) {
	switch t := t.Underlying().(type) {
	case *types.Basic:
		if t.Kind() == types.String {
			// unlike other basic types, strings have a pointer indirection
			g.generateString(name, indir)
		} else {
			g.generateBasic(name, indir)
		}
	case *types.Array:
		g.generateArray(name, t, indir, loopVar)
	case *types.Struct:
		g.generateStruct(name, t, indir, loopVar)
	case *types.Pointer:
		g.generatePointer(name, t, indir, loopVar)
	case *types.Slice:
		g.generateSlice(name, t, indir, loopVar)
	default:
		log.Fatal("cannot encode type: " + t.String())
	}
}

const writeTempl = `
	n, err = w.Write(*(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{Data: %[1]s, Len: %[2]s, Cap: %[2]s})))
	if err != nil {
		return
	}
	total += int64(n)
`

func (g *generator) generateBasic(name string, indir int) {
	ptr := fmt.Sprintf("uintptr(unsafe.Pointer(%s))", ref(name, indir))
	size := fmt.Sprintf("int(unsafe.Sizeof(%s))", deref(name, indir))
	g.Printf(writeTempl, ptr, size)
}

func (g *generator) generateArray(name string, t *types.Array, indir int, loopVar byte) {
	if t.Len() == 0 {
		return
	}
	if isContiguous(t) {
		g.generateBasic(name, indir)
		return
	}

	g.Printf("\nfor %c := range %s {", loopVar, deref(name, indir-1))
	innerName := fmt.Sprintf("%s[%c]", deref(name, indir-1), loopVar)
	g.generate(innerName, t.Elem(), indir, loopVar+1)
	g.Printf("}\n")
}

func (g *generator) generateStruct(name string, st *types.Struct, indir int, loopVar byte) {
	for i := 0; i < st.NumFields(); i++ {
		// slow path, including single continuous fields
		if !isContiguous(st.Field(i).Type()) || i == st.NumFields()-1 || !isContiguous(st.Field(i+1).Type()) {
			g.generate(deref(name, indir-1)+"."+st.Field(i).Name(), st.Field(i).Type(), indir-1, loopVar)
			continue
		}

		// group contiguous fields into a single write
		// NOTE: struct padding will be included
		startField := deref(name, indir-1) + "." + st.Field(i).Name()
		for j := i + 1; j < st.NumFields() && isContiguous(st.Field(j).Type()); j++ {
			i++
		}
		endField := deref(name, indir-1) + "." + st.Field(i).Name()
		runPtr := fmt.Sprintf("uintptr(unsafe.Pointer(&%s))", startField)
		runSize := fmt.Sprintf("int(unsafe.Offsetof(%[1]s)+unsafe.Sizeof(%[1]s) - unsafe.Offsetof(%[2]s))", endField, startField)
		g.Printf(writeTempl, runPtr, runSize)
	}
}

func (g *generator) generatePointer(name string, t *types.Pointer, indir int, loopVar byte) {
	g.Printf("\nif %v != nil {", name)
	g.generateBasic("ptrTrue", 0)
	g.generate(name, t.Elem(), indir+1, loopVar)
	g.Printf("} else {")
	g.generateBasic("ptrFalse", 0)
	g.Printf("}\n")
}

func (g *generator) generateString(name string, indir int) {
	g.Printf("\nstr = (*reflect.StringHeader)(unsafe.Pointer(%s))", ref(name, indir))
	g.generateBasic("str.Len", 0)
	g.Printf("if str.Len != 0 {")
	g.Printf(writeTempl, "str.Data", "str.Len")
	g.Printf("}")
}

func (g *generator) generateSlice(name string, t *types.Slice, indir int, loopVar byte) {
	g.Printf("\nsli = (*reflect.SliceHeader)(unsafe.Pointer(%s))", ref(name, indir))
	g.generateBasic("sli.Len", 0)

	if isContiguous(t.Elem()) {
		g.Printf(writeTempl, "sli.Data", fmt.Sprintf("sli.Len * int(unsafe.Sizeof(%s[0]))", deref(name, indir)))
		return
	}

	g.Printf("\nfor %c := range %s {", loopVar, deref(name, indir))
	innerName := fmt.Sprintf("%s[%c]", deref(name, indir), loopVar)
	g.generate(innerName, t.Elem(), indir, loopVar+1)
	g.Printf("}\n")
}
