package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"strings"
)

// isContiguous returns true if all of t's data (at least, the data that we
// care about) lies in one contiguous segment of memory. This includes all
// basic types (except strings), arrays of contiguous types, and structs
// containing only contiguous types.
func isContiguous(t types.Type) bool {
	switch t := t.Underlying().(type) {
	case *types.Basic:
		return t.Kind() != types.String
	case *types.Array:
		return isContiguous(t.Elem())
	case *types.Struct:
		for i := 0; i < t.NumFields(); i++ {
			if !isContiguous(t.Field(i).Type()) {
				return false
			}
		}
		return true
	}
	return false
}

type generator struct {
	buf     bytes.Buffer
	loopVar byte // i, j, k, etc.
	ptr     bool // true if var currently being encoded is a pointer
}

func (g *generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalln("invalid Go generated:", err)
	}
	return src
}

func (g *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *generator) generateHeader(pkgName string) {
	g.Printf(`// Code generated by few; edit if you feel like it.

package %s

import (
	"errors"
	"io"
	"reflect"
	"unsafe"
)

var (
	_            unsafe.Pointer
	errNilObject = errors.New("cannot encode nil object")
	ptrTrue      = true
	ptrFalse     = false
)
`, pkgName)
}

func (g *generator) generateMethod(name string, t types.Type) {
	g.Printf(`
func (x *%s) WriteTo(w io.Writer) (total int64, err error) {
	if x == nil {
		return 0, errNilObject
	}
	var n int
	var sli *reflect.SliceHeader
	var str *reflect.StringHeader
	_, _, _ = n, sli, str // evade unused variable check
`, name)
	g.ptr = true
	g.loopVar = 'i'
	g.generate("x", t)
	g.Printf(`
	return
}`)
}

func (g *generator) generate(name string, t types.Type) {
	switch t := t.Underlying().(type) {
	case *types.Basic:
		if t.Kind() == types.String {
			// unlike other basic types, strings have a pointer indirection
			g.generateString(name)
		} else {
			g.generateBasic(name)
		}
	case *types.Array:
		g.generateArray(name, t)
	case *types.Struct:
		g.generateStruct(name, t)
	case *types.Pointer:
		g.generatePointer(name, t)
	case *types.Slice:
		g.generateSlice(name, t)
	default:
		log.Fatal("cannot encode type: " + t.String())
	}
}

const writeTempl = `
	n, err = w.Write(*(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{Data: %[1]s, Len: %[2]s, Cap: %[2]s})))
	if err != nil {
		return
	}
	total += int64(n)
`

func (g *generator) ref(name string) string {
	if g.ptr {
		return name
	}
	return "&" + name
}

func (g *generator) deref(name string) string {
	if g.ptr {
		return "(*" + name + ")"
	}
	return name
}

func (g *generator) generateConst(name string) {
	ptr := fmt.Sprintf("uintptr(unsafe.Pointer(&%s))", name)
	size := fmt.Sprintf("int(unsafe.Sizeof(%s))", name)
	g.Printf(writeTempl, ptr, size)
}

func (g *generator) generateBasic(name string) {
	ptr := fmt.Sprintf("uintptr(unsafe.Pointer(%s))", g.ref(name))
	size := fmt.Sprintf("int(unsafe.Sizeof(%s))", g.deref(name))
	g.Printf(writeTempl, ptr, size)
}

func (g *generator) generateArray(name string, t *types.Array) {
	if t.Len() == 0 {
		return
	}
	if isContiguous(t) {
		g.generateBasic(name)
		return
	}

	g.Printf("\nfor %c := range %s {", g.loopVar, g.deref(name))
	innerName := fmt.Sprintf("%s[%c]", g.deref(name), g.loopVar)
	g.loopVar++ // increment loopVar for each nested loop
	g.generate(innerName, t.Elem())
	g.loopVar--
	g.Printf("}\n")
}

func (g *generator) generateStruct(name string, st *types.Struct) {
	for i := 0; i < st.NumFields(); i++ {
		// slow path
		if !isContiguous(st.Field(i).Type()) {
			g.generate(name+"."+st.Field(i).Name(), st.Field(i).Type())
			continue
		}

		// group contiguous fields into a single write
		// NOTE: struct padding will be included
		var sizes []string
		for j := i; j < st.NumFields() && isContiguous(st.Field(j).Type()); j++ {
			sizes = append(sizes, fmt.Sprintf("unsafe.Sizeof(%s.%s)", name, st.Field(j).Name()))
		}
		groupStart := fmt.Sprintf("uintptr(unsafe.Pointer(&%s.%s))", name, st.Field(i).Name())
		groupSize := fmt.Sprintf("int(%s)", strings.Join(sizes, "+"))
		g.Printf(writeTempl, groupStart, groupSize)
		i += len(sizes) - 1
	}
}

func (g *generator) generatePointer(name string, t *types.Pointer) {
	// TODO: eliminate &*
	g.Printf("\nif %v != nil {", name)
	g.generateConst("ptrTrue")
	g.ptr = true
	g.generate(name, t.Elem())
	g.ptr = false
	g.Printf("} else {")
	g.generateConst("ptrFalse")
	g.Printf("}\n")
}

func (g *generator) generateString(name string) {
	g.Printf("\nstr = (*reflect.StringHeader)(unsafe.Pointer(%s))", g.ref(name))
	g.generateConst("str.Len")
	g.Printf("if str.Len != 0 {")
	g.Printf(writeTempl, "str.Data", "str.Len")
	g.Printf("}")
}

func (g *generator) generateSlice(name string, t *types.Slice) {
	g.Printf("\nsli = (*reflect.SliceHeader)(unsafe.Pointer(%s))", g.ref(name))
	g.generateConst("sli.Len")

	if isContiguous(t.Elem()) {
		g.Printf(writeTempl, "sli.Data", fmt.Sprintf("sli.Len * int(unsafe.Sizeof(%s[0]))", g.deref(name)))
		return
	}

	g.Printf("\nfor %c := range %s {", g.loopVar, g.deref(name))
	innerName := fmt.Sprintf("%s[%c]", g.deref(name), g.loopVar)
	g.loopVar++ // increment loopVar for each nested loop
	g.generate(innerName, t.Elem())
	g.loopVar--
	g.Printf("}\n")
}
